# -*- coding: utf-8 -*-
"""Kenny-Duy-Nguyen_Kevin-Li_Term-Project_Frisbee-Modeling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s5shOF0mgz_czDXYJd5DCvWjmScQ7w5X

# Term Project 1
360-420-DW 

Introduction to Computer Programming in Engineering and Science

Section 1

Report made by:


*   Kevin-Ruikai Li
*   Kenny Duy Nguyen

Link for the report on Google Docs:
https://docs.google.com/document/d/1gaFYqhYyBB867FuEYGhX_p5haUFtJhU249hTesn3EwA/edit?usp=sharing

# Modelling the Flight of a Frisbee
"""

import math
import numpy as np
import matplotlib.pyplot as plt

class Projectile(object):
  # constants which apply for all instances
  DT = 0.01
  T_MAX = 5.0
  STEPS = int(T_MAX/DT)
  g=9.81

  def __init__(self,x_0,y_0,v_0,theta_0,**kwargs):
    """
    Constructor method for new instances
    """
    # unpack initial position, velocity and theta
    self.x_0 = x_0
    self.y_0 = y_0
    self.v_0 = v_0
    self.theta_0 = theta_0

    # make lists for this instance, where first element is initial value
    self.t = [0,]
    self.x = [self.x_0,]
    self.y = [self.y_0,]
    self.vx = [self.v_0*math.cos(math.radians(self.theta_0)),]
    self.vy = [self.v_0*math.sin(math.radians(self.theta_0)),]
    self.ax = [0,]
    self.ay = [-1*self.g,]

  def update_position(self,i):
    """
    Update x position and y position at time step i
    """
    self.x.append(self.x[i]+self.vx[i]*self.DT)
    self.y.append(self.y[i]+self.vy[i]*self.DT)
    return

  def update_velocity(self,i):
    """
    Update x velocity and y velocity at time step i
    """
    self.vx.append(self.vx[i]+self.ax[i]*self.DT)
    self.vy.append(self.vy[i]+self.ay[i]*self.DT)
    return

  def update_acceleration(self,i):
    """
    Update x acceleration and y acceleration at time step i
    """
    self.ax.append(self.ax[i])
    self.ay.append(self.ay[i])
    return

  def simulate(self):
    """
    Main Loop
    """
    for i in range(self.STEPS):
      self.t.append(self.t[i]+self.DT)
      self.update_acceleration(i)
      self.update_velocity(i)
      self.update_position(i)

      if self.y[i] < 0.:
        break
    return

class Frisbee(Projectile):

  def __init__(self,m,rho,A,inclination_0,**kwargs):
    """
    Add extra arguments for an instance
    """
    super().__init__(**kwargs)
    self.m = m
    self.rho = rho
    self.A = A
    self.inclination_0 = inclination_0
    
  def update_forces(self, i):
    """
    Update drag and lift forces at time step i
    """
    #Calculate the angle of attack
    self.theta_velocity = math.atan(self.vy[i]/self.vx[i])
    self.alpha = math.radians(self.inclination_0) - self.theta_velocity
    #Calculate the drag and lift coefficients
    self.c_lift = 3.09*self.alpha + 0.13
    self.c_drag = 0.085 + 3.30*((self.alpha + 0.052)**2)
    #Calculate the drag and lift forces
    self.drag_force = (1/2)*self.rho*self.A*self.c_drag*(self.vx[i]**2+self.vy[i]**2)
    self.lift_force = (1/2)*self.rho*self.A*self.c_lift*(self.vx[i]**2+self.vy[i]**2)

  def update_acceleration(self, i):
    """
    Update x acceleration and y acceleration at time step i
    """
    self.update_forces(i)
    self.ax.append((1/self.m)*(-(self.drag_force*math.cos(self.theta_velocity)) - (self.lift_force*math.sin(self.theta_velocity))))
    self.ay.append((1/self.m)*(-(self.m*self.g) - (self.drag_force*math.sin(self.theta_velocity)) + (self.lift_force*math.cos(self.theta_velocity))))
    return

#Plot the graph for different inclinations
plt.style.use('ggplot')
plt.figure(figsize=(25,10))
plt.locator_params('x', nbins=20)

for inclination in np.arange(3,11,1):
  kevsfrisbee=Frisbee(
    x_0=0,
    y_0=1,
    v_0=14,
    theta_0=0,
    m=0.175,
    rho=1.28,
    A=math.pi*0.13**2,
    inclination_0=inclination
  )

  kevsfrisbee.simulate()
  plt.plot(kevsfrisbee.x, kevsfrisbee.y,label='Initial inclination of '+str(inclination)+' degrees')
  print (max(kevsfrisbee.x))
  print (max(kevsfrisbee.y))

plt.ylim(ymin=0,ymax=3)
plt.xlabel('Position in x')
plt.ylabel('Position in y')
plt.title('Trajectory of a frisbee thrown horizontally with different inclinations')
plt.legend()

#Plot a graph that zooms in on the landing
plt.style.use('ggplot')
plt.figure(figsize=(25,10))

for inclination in np.arange(3,11,1):
  kevsfrisbee=Frisbee(
    x_0=0,
    y_0=1,
    v_0=14,
    theta_0=0,
    m=0.175,
    rho=1.28,
    A=math.pi*0.13**2,
    inclination_0=inclination
  )

  kevsfrisbee.simulate()
  plt.plot(kevsfrisbee.x, kevsfrisbee.y,label='Initial inclination of '+str(inclination)+' degrees')

plt.ylim(ymin=0,ymax=1)
plt.xlim(xmin=24,xmax=26)
plt.xlabel('Position in x')
plt.ylabel('Position in y')
plt.title('Trajectory of a frisbee thrown horizontally with different inclinations (Landing)')
plt.legend()

"""# Validation 

We ran our code again with different values for the drag and lift coefficients.
"""

class Frisbee(Projectile):

  def __init__(self,m,rho,A,inclination_0,**kwargs):
    """
    Add extra arguments for an instance
    """
    super().__init__(**kwargs)
    self.m = m
    self.rho = rho
    self.A = A
    self.inclination_0 = inclination_0
    
  def update_forces(self, i):
    """
    Update drag and lift forces at time step i
    """
    #Calculate the angle of attack
    self.theta_velocity = math.atan(self.vy[i]/self.vx[i])
    self.alpha = math.radians(self.inclination_0) - self.theta_velocity
    #Calculate the drag and lift coefficients
    self.c_lift = 1.4*self.alpha + 0.15
    self.c_drag = 0.08 + 2.72*((self.alpha + 0.0698)**2)
    #Calculate the drag and lift forces
    self.drag_force = (1/2)*self.rho*self.A*self.c_drag*(self.vx[i]**2+self.vy[i]**2)
    self.lift_force = (1/2)*self.rho*self.A*self.c_lift*(self.vx[i]**2+self.vy[i]**2)

  def update_acceleration(self, i):
    """
    Update x acceleration and y acceleration at time step i
    """
    self.update_forces(i)
    self.ax.append((1/self.m)*(-(self.drag_force*math.cos(self.theta_velocity)) - (self.lift_force*math.sin(self.theta_velocity))))
    self.ay.append((1/self.m)*(-(self.m*self.g) - (self.drag_force*math.sin(self.theta_velocity)) + (self.lift_force*math.cos(self.theta_velocity))))
    return

plt.style.use('ggplot')
plt.figure(figsize=(25,10))
plt.locator_params('x', nbins=20)

for inclination in np.arange(3,11,1):
  kevsfrisbee=Frisbee(
    x_0=0,
    y_0=1,
    v_0=14,
    theta_0=0,
    m=0.175,
    rho=1.23,
    A=math.pi*0.13**2,
    inclination_0=inclination
  )

  kevsfrisbee.simulate()
  plt.plot(kevsfrisbee.x, kevsfrisbee.y,label='Initial inclination of '+str(inclination)+' degrees')
  print (max(kevsfrisbee.x))

plt.ylim(ymin=0,ymax=3)
plt.xlabel('Position in x')
plt.ylabel('Position in y')
plt.title('Trajectory of a frisbee thrown horizontally with different inclinations')
plt.legend()